<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<event category="STEP" id="0">
  <actions>
    <action id="603" library="1">
      <!--action name: Code-->
      <kind>CODE</kind>
      <allowRelative>false</allowRelative>
      <question>false</question>
      <canApplyTo>true</canApplyTo>
      <actionType>CODE</actionType>
      <functionName/>
      <relative>false</relative>
      <not>false</not>
      <appliesTo>.self</appliesTo>
      <arguments>
        <argument kind="STRING">if (!visible) exit;

var i, button, xOfsset, yOffset, ySize, xSize;
xOffset = view_xview[0] + startX;
ySize = view_hview[0];
yOffset = view_yview[0] + ySize;
xSize = view_wview[0];
canClick = true;
tooltipIdx = -1;

if (instance_exists(MenuController) || mouse_x &gt; view_xview[0]+view_wview[0] || mouse_x &lt; view_xview[0] || mouse_y &gt; view_yview[0]+view_hview[0] || mouse_y &lt; view_yview[0]) canClick = false;
else {
    if (keyboard_check(vk_left)) {
        view_xview[0] -= moveSpeed*global.delta_factor;
        event_user(1);
    } else if (keyboard_check(vk_right)) {
        view_xview[0] += moveSpeed*global.delta_factor;
        event_user(1);
    } 
    if (keyboard_check(vk_up)) {
        view_yview[0] -= moveSpeed*global.delta_factor;
        event_user(1);
    } else if (keyboard_check(vk_down)) {
        view_yview[0] += moveSpeed*global.delta_factor;
        event_user(1);
    }
}

if (expanded) {
    expandIdx = max(0, expandIdx - 0.05*global.delta_factor);
    
    if (expandIdx != 0 &amp;&amp; expanded) {
        height = items*buttonHeight * sqrt(1-expandIdx*0.93);
        dragHeight = height;
    } else height = items*buttonHeight;
    
    if (holdHeader) {
        if (toggleHeader &amp;&amp; (abs(holdX-mouse_x) &gt; 3 || abs(holdY-mouse_y) &gt; 3)) toggleHeader = false;
        else if (!toggleHeader) {
            startX += mouse_x-holdX;
            startX = min(xSize-headerWidth, max(0, startX));
            holdX = mouse_x;
            
            dragHeight -= mouse_y-holdY;
            holdY = mouse_y;
            dragHeight = min(ySize, max(buttonHeight, dragHeight));
            items = min(ceil(dragHeight/buttonHeight), ds_list_size(global.buttons));
            height = items*buttonHeight;
        }
        
        if (!mouse_check_button(mb_left)) {
            holdHeader = false;
            if (toggleHeader) {
                expanded = !expanded;
                oldItems = items;
            }
        }
    } else if (!holdHeader2) {
        dragHeight = max(height, dragHeight - max(2, (dragHeight-height)/16)*global.delta_factor);
    
        if (mouse_x &gt; xOffset &amp;&amp; mouse_x &lt; xOffset+buttonWidth) {
            if (mouse_y &gt; yOffset-dragHeight-buttonHeight &amp;&amp; mouse_y &lt; yOffset-dragHeight) {
                canClick = false;
                if (mouse_check_button_pressed(mb_left)) {
                    holdHeader = true;
                    toggleHeader = true;
                    holdX = mouse_x;
                    holdY = mouse_y;
                    canClick = false;
                }
            } else if (mouse_y &gt; yOffset-height) {
                canClick = false;
                if (mouse_check_button_pressed(mb_left)) {
                    button = items - 1 - floor((yOffset-mouse_y)/height*items) + scrollIndex;
                    if (!buttons[button, TOGGLE]) {
                        execute_string(ds_map_find_value(ds_list_find_value(global.buttons, button), "code"), true);
                    } else {
                        buttons[button, TOGGLED] = execute_string(ds_map_find_value(ds_list_find_value(global.buttons, button), "code"), !buttons[button, TOGGLED]);
                    }
                }
            }
        } else if (mouse_x &gt; xOffset+buttonWidth &amp;&amp; mouse_x &lt; xOffset+headerWidth) {
            if (mouse_y &gt; yOffset-height) {
                if (mouse_check_button(mb_left)) scrollIndex = floor((1-(yOffset-mouse_y)/height)*(ds_list_size(global.buttons)-items));
                canClick = false;
            }
        }
    }
    
    if (!canClick) {
        if (mouse_wheel_up()) scrollIndex -= 1;
        else if (mouse_wheel_down()) scrollIndex += 1;
    }
    scrollIndex = max(0, min(ds_list_size(global.buttons)-floor(height/buttonHeight), scrollIndex));
} else {
    expandIdx = min(1, expandIdx + 0.05*global.delta_factor);
    height *= sqrt(1-expandIdx*0.93);
    dragHeight = height;
    items = min(ds_list_size(global.buttons), ceil(height/buttonHeight));
    
    if (mouse_x &gt; xOffset &amp;&amp; mouse_x &lt; xOffset+buttonWidth) {
        if (mouse_y &gt; yOffset-dragHeight-buttonHeight &amp;&amp; mouse_y &lt; yOffset-dragHeight) {
            if (mouse_check_button_pressed(mb_left)) {
                expanded = true;
                items = oldItems;
                canClick = false;
            }
        }
    }
}

// Not hovering over the button menu
if (canClick) {
    xOffset = view_xview[0] + startX2;
    yOffset = view_yview[0] + startY2;
    
    if (holdHeader2) {
        startX2 += mouse_x-holdX;
        startX2 = min(xSize-entityButtonSize*vItems, max(0, startX2));
        holdX = mouse_x;
        
        startY2 += mouse_y-holdY;
        startY2 = min(ySize-2*entityButtonSize, max(0, startY2));
        holdY = mouse_y;
        
        if (!mouse_check_button(mb_left)) holdHeader2 = false;
    } else if (mouse_x &gt; xOffset &amp;&amp; mouse_x &lt; xOffset+entityButtonSize*vItems) {
        if (mouse_y &gt; yOffset+buttonHeight &amp;&amp; mouse_y &lt; yOffset+buttonHeight+entityButtonSize*ceil(entityButtonCount/vItems)) {
            i = floor((mouse_x-xOffset)/entityButtonSize) + floor((mouse_y-yOffset-buttonHeight)/entityButtonSize)*vItems;
            canClick = false;
            if (i &lt; entityButtonCount) {
                tooltipIdx = i;
                if (mouse_check_button_pressed(mb_left)) {
                    if (selected != i) {
                        selected = i;
                        event_user(2);
                    }
                } else if (mouse_check_button_pressed(mb_right)) {
                    if (selected != i) {
                        selected = i;
                        event_user(2);
                    }
                    showPropertyMenu(selectedProperties, newProperties);
                }
            }
        } else if (mouse_y &gt; yOffset &amp;&amp; mouse_y &lt; yOffset+buttonHeight) {
            canClick = false;
            if (mouse_check_button_pressed(mb_left)) {
                holdHeader2 = true;
                holdX = mouse_x;
                holdY = mouse_y;
            }
        }
    }
}

// Not hovering over any menus
if (canClick) {
    if (mouse_check_button_pressed(mb_left) &amp;&amp; selected != -1) {
        scaling = true;
        scaleX = round(mouse_x/6)*6;
        scaleY = round(mouse_y/6)*6;
    } else if (mouse_check_button_pressed(mb_right)) {
        erasing = true;
        scaleX = round(mouse_x/6)*6;
        scaleY = round(mouse_y/6)*6;
        selected = -1;
        mirrored = -1;
    } else if (mouse_check_button_pressed(mb_middle)) {
        with(LevelEntity) {
            if (collision_point(mouse_x, mouse_y, id, true, false) &gt; 0) {
                other.selected = ds_list_find_index(global.entities, type);
                with(other) event_user(2);
                break;
            }
        }
    }
}

// Fill in the selected area if the users stops scaling.
if ((mouse_check_button_released(mb_left) || !scale) &amp;&amp; scaling) {
    scaling = false;
    if (scale &amp;&amp; entityButtons[selected, SCALE]) {
        var entity, entity2 xscale, yscale, _x, _y;
        _x = max(scaleX+6, round(mouse_x/6)*6+spriteCenterX);
        _y = max(scaleY+6, round(mouse_y/6)*6+spriteCenterY);
        xscale = (_x-scaleX) / sprite_get_width(selectedSprite);
        yscale = (_y-scaleY) / sprite_get_height(selectedSprite);
        
        entity = instance_create(scaleX-spriteCenterX+spriteOffsetX*xscale, scaleY-spriteCenterY+spriteOffsetY*yscale, LevelEntity);
        entity.sprite_index = selectedSprite;
        entity.image_index = selectedImage;
        entity.type = ds_list_find_value(global.entities, entityButtons[selected, INDEX]);
        entity.image_xscale = xscale;
        entity.image_yscale = yscale;
        if (ds_map_size(newProperties) &gt; 0) entity.properties = ggon_duplicate_map(newProperties);

        if (symmetry) {
            entity2 = instance_create(map_width()-scaleX+spriteCenterX+spriteOffsetX*xscale-(_x-scaleX), scaleY-spriteCenterY+spriteOffsetY*yscale, LevelEntity);
            entity2.sprite_index = mirroredSprite;
            entity2.image_index = mirroredImage;
            entity2.type = ds_list_find_value(global.entities, mirrored);
            entity2.image_xscale = xscale;
            entity2.image_yscale = yscale;
            if (ds_map_size(newProperties) &gt; 0) entity.properties = ggon_duplicate_map(newProperties);
        }
        execute_string(global.placeEntityFunction, entity);
    } else {
        var _x, _y, i, j, entity, entity2;
        _x = max(sprite_get_width(selectedSprite)+scaleX, scaleX+ceil((mouse_x-scaleX)/sprite_get_width(selectedSprite))*sprite_get_width(selectedSprite));
        _y = max(sprite_get_height(selectedSprite)+scaleY, scaleY+ceil((mouse_y-scaleY)/sprite_get_height(selectedSprite))*sprite_get_height(selectedSprite));

        for(i=scaleX-spriteCenterX; i+spriteCenterX&lt;_x; i+=sprite_get_width(selectedSprite)) {      
            for(j=scaleY-spriteCenterY; j+spriteCenterY&lt;_y; j+=sprite_get_height(selectedSprite)) {
                entity = instance_create(i+spriteOffsetX, j+spriteOffsetY, LevelEntity);
                entity.sprite_index = selectedSprite;
                entity.image_index = selectedImage;
                entity.type = ds_list_find_value(global.entities, entityButtons[selected, INDEX]);
                if (ds_map_size(newProperties) &gt; 0) entity.properties = ggon_duplicate_map(newProperties);
    
                if (symmetry) {
                    if (mirrored != -1) {                                  
                        entity2 = instance_create(map_width()-i+mirroredOffsetX, j+spriteOffsetY, LevelEntity);
                        entity2.sprite_index = mirroredSprite;
                        entity2.image_index = mirroredImage;
                        entity2.type = ds_list_find_value(global.entities, mirrored);
                        if (ds_map_size(newProperties) &gt; 0) entity.properties = ggon_duplicate_map(newProperties);
                    }
                }
                execute_string(global.placeEntityFunction, entity);
            }
        }
    }
} else if ((mouse_check_button_released(mb_right)) &amp;&amp; erasing) {
    var area;
    area = (mouse_x-6 &gt;= scaleX || mouse_y-6 &gt;= scaleY);
    erasing = false;
    
    if (area) {
        with(LevelEntity) if (x &gt;= other.scaleX &amp;&amp; x &lt;= mouse_x &amp;&amp; y &gt;= other.scaleY &amp;&amp; y &lt;= mouse_y) instance_destroy();
    } else {
        with(LevelEntity) if (collision_point(mouse_x, mouse_y, id, true, false) &gt; 0) instance_destroy();
    }
    
    if (symmetry) {
        var _x;
        scaleX = map_width() - scaleX;
        _x = map_width() - mouse_x;
        
        if (area) {
            with(LevelEntity) if (x &lt;= other.scaleX &amp;&amp; x &gt;= _x &amp;&amp; y &gt;= other.scaleY &amp;&amp; y &lt;= mouse_y) instance_destroy();
        } else {
            with(LevelEntity) if (collision_point(_x, mouse_y, id, true, false) &gt; 0) instance_destroy();
        }
    } 
}
</argument>
      </arguments>
    </action>
  </actions>
</event>
